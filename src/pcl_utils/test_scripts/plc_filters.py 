import open3d
import numpy as np

import pcl_utils.open3d_ros_helperV2 as o3d_ros
from pcl_utils.surface_reconstruction_lib import supress_plane, statistical_outlier_removal

import rclpy
from rclpy.node import Node
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor


from sensor_msgs.msg import PointCloud2
from std_srvs.srv import Trigger

import copy

class FilterPCL(Node):
    def __init__(self):
        super().__init__('test_pcl_filter')
        self.cb_group = ReentrantCallbackGroup()
        
        self.create_subscription(PointCloud2, '/realsense_d405/points', self.point_cloud_callback, 1, callback_group=self.cb_group)
        self.create_service(Trigger, 'store_latest_o3d_pcd', self.store_o3d_pcd_callback, callback_group=self.cb_group)
        self.create_service(Trigger, 'visualize_pipeline', self.visualize_pipeline_callback, callback_group=self.cb_group)
        
        # Publishers for filtered point clouds
        self.filtered_pub = self.create_publisher(PointCloud2, '/filtered_pointcloud', 10)
        self.object_pub = self.create_publisher(PointCloud2, '/object_pointcloud', 10)

        # Storage for different processing stages
        self.latest_o3d_pcd = open3d.geometry.PointCloud()
        self.raw_pcd = open3d.geometry.PointCloud()
        self.cropped_pcd = open3d.geometry.PointCloud()
        self.downsampled_pcd = open3d.geometry.PointCloud()
        self.denoised_pcd = open3d.geometry.PointCloud()
        self.object_pcd = open3d.geometry.PointCloud()  # After plane removal
        
        # Processing parameters
        self.x_range = [-0.5, 0.5]  # meters
        self.y_range = [-0.5, 0.5]  # meters
        self.z_range = [0.3, 1.2]   # meters
        self.voxel_size = 0.005  # 5mm voxels for downsampling
        self.enable_visualization = False  # Set to True to see each step
        
        self.get_logger().info('FilterPCL node initialized. Call /visualize_pipeline service to see processing stages.')

    def point_cloud_callback(self, msg):
        """
        Complete point cloud processing pipeline:
        1. Convert ROS -> Open3D
        2. Pass-through filter (crop to ROI)
        3. Voxel downsampling (reduce density, improve performance)
        4. Statistical outlier removal (remove noise)
        5. Plane segmentation and removal (remove table/ground)
        """
        try:
            # Step 1: Convert ROS PointCloud2 to Open3D
            self.get_logger().info('Received point cloud with %d points' % (msg.width * msg.height))
            self.raw_pcd = o3d_ros.ros2pc_to_o3dpc(msg)
            
            if len(self.raw_pcd.points) == 0:
                self.get_logger().warn('Received empty point cloud!')
                return
            
            # Step 2: Apply pass-through filter to focus on region of interest
            self.get_logger().info('Step 1: Raw point cloud has %d points' % len(self.raw_pcd.points))
            self.cropped_pcd = o3d_ros.apply_pass_through_filter(
                self.raw_pcd, self.x_range, self.y_range, self.z_range
            )
            self.get_logger().info('Step 2: After pass-through filter: %d points' % len(self.cropped_pcd.points))
            
            if len(self.cropped_pcd.points) < 100:
                self.get_logger().warn('Too few points after cropping! Check your filter ranges.')
                return
            
            # Step 3: Voxel downsampling for efficiency
            # Reduces point density while preserving structure
            self.downsampled_pcd = self.cropped_pcd.voxel_down_sample(voxel_size=self.voxel_size)
            self.get_logger().info('Step 3: After voxel downsampling: %d points' % len(self.downsampled_pcd.points))
            
            # Step 4: Statistical outlier removal to remove noise
            # Removes points that are far from their neighbors (sensor noise, flying pixels)
            self.denoised_pcd = statistical_outlier_removal(self.downsampled_pcd)
            self.get_logger().info('Step 4: After denoising: %d points' % len(self.denoised_pcd.points))
            
            # Step 5: Remove the dominant plane (table/ground)
            # Uses RANSAC to detect and remove the table plane
            self.object_pcd = supress_plane(self.denoised_pcd)
            self.get_logger().info('Step 5: After plane removal: %d points (object only)' % len(self.object_pcd.points))
            
            # Store the final result
            self.latest_o3d_pcd = copy.deepcopy(self.object_pcd)
            
            # Optional: Estimate normals for the final object (useful for mesh reconstruction later)
            if len(self.object_pcd.points) > 50:
                self.object_pcd.estimate_normals(
                    search_param=open3d.geometry.KDTreeSearchParamHybrid(radius=0.02, max_nn=30)
                )
                self.get_logger().info('Normals estimated for object point cloud')
            
            # Publish filtered point clouds back to ROS for RViz visualization
            if len(self.denoised_pcd.points) > 0:
                filtered_ros = o3d_ros.o3dpc_to_rospc(self.denoised_pcd, frame_id=msg.header.frame_id)
                self.filtered_pub.publish(filtered_ros)
            
            if len(self.object_pcd.points) > 0:
                object_ros = o3d_ros.o3dpc_to_rospc(self.object_pcd, frame_id=msg.header.frame_id)
                self.object_pub.publish(object_ros)
            
            self.get_logger().info('Processing complete! Final object has %d points' % len(self.latest_o3d_pcd.points))
            
        except Exception as e:
            self.get_logger().error('Error in point cloud processing: %s' % str(e))
        

    def visualize_stages(self, pcd_list, titles, colors=None):
        """
        Visualize multiple point clouds side by side with different colors
        Args:
            pcd_list: List of Open3D point clouds
            titles: List of titles for each point cloud
            colors: List of RGB colors (0-1 range) for each point cloud
        """
        if colors is None:
            colors = [
                [1, 0, 0],      # Red
                [0, 1, 0],      # Green
                [0, 0, 1],      # Blue
                [1, 1, 0],      # Yellow
                [1, 0, 1],      # Magenta
                [0, 1, 1],      # Cyan
            ]
        
        colored_pcds = []
        offset = 0.0
        
        for i, (pcd, title) in enumerate(zip(pcd_list, titles)):
            if len(pcd.points) == 0:
                continue
            
            pcd_copy = copy.deepcopy(pcd)
            pcd_copy.paint_uniform_color(colors[i % len(colors)])
            
            # Offset each point cloud horizontally for comparison
            pcd_copy.translate([offset, 0, 0])
            
            # Calculate offset based on bounding box
            bbox = pcd_copy.get_axis_aligned_bounding_box()
            offset += (bbox.max_bound[0] - bbox.min_bound[0]) + 0.1
            
            colored_pcds.append(pcd_copy)
            self.get_logger().info('%s: %d points' % (title, len(pcd.points)))
        
        # Add coordinate frame for reference
        coord_frame = open3d.geometry.TriangleMesh.create_coordinate_frame(size=0.1, origin=[0, 0, 0])
        colored_pcds.append(coord_frame)
        
        open3d.visualization.draw_geometries(colored_pcds, window_name="Point Cloud Processing Pipeline")
    
    def visualize_pipeline_callback(self, request, response):
        """
        Service to visualize all processing stages side by side
        """
        self.get_logger().info('Visualizing processing pipeline...')
        
        if len(self.raw_pcd.points) == 0:
            response.success = False
            response.message = 'No point cloud data available. Wait for a message first.'
            return response
        
        pcd_list = [
            self.raw_pcd,
            self.cropped_pcd,
            self.downsampled_pcd,
            self.denoised_pcd,
            self.object_pcd
        ]
        
        titles = [
            'Raw',
            'Cropped',
            'Downsampled',
            'Denoised',
            'Object (no plane)'
        ]
        
        self.visualize_stages(pcd_list, titles)
        
        response.success = True
        response.message = 'Visualization complete'
        return response

    def store_o3d_pcd_callback(self, request, response):
        """
        Service to save the processed point cloud to disk
        """
        self.get_logger().info('Store PCD service called')
        
        if len(self.latest_o3d_pcd.points) == 0:
            response.success = False
            response.message = 'No point cloud data to save'
            return response
        
        try:
            # Save all processing stages
            open3d.io.write_point_cloud("raw_pcd.pcd", self.raw_pcd)
            open3d.io.write_point_cloud("cropped_pcd.pcd", self.cropped_pcd)
            open3d.io.write_point_cloud("downsampled_pcd.pcd", self.downsampled_pcd)
            open3d.io.write_point_cloud("denoised_pcd.pcd", self.denoised_pcd)
            open3d.io.write_point_cloud("object_pcd.pcd", self.object_pcd)
            open3d.io.write_point_cloud("latest_o3d_pcd_copy.pcd", self.latest_o3d_pcd)
            
            response.success = True
            response.message = 'All PCD files saved successfully (raw, cropped, downsampled, denoised, object, latest)'
            self.get_logger().info(response.message)
        except Exception as e:
            response.success = False
            response.message = 'Failed to save PCD: %s' % str(e)
            self.get_logger().error(response.message)
        
        return response
        


def main():
    rclpy.init()
    node = FilterPCL()
    exec = MultiThreadedExecutor(num_threads=2) 
    exec.add_node(node)
    try:
        exec.spin()
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()